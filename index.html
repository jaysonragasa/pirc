<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>pIRC — mIRC-style web chat</title>
  <!-- Tailwind via CDN (Play CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* small extra styles to emulate mIRC look */
    .mircss {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 0.95rem;
    }
    .msg-user { font-weight: 600; }
    .msg-system { color: #9ca3af; font-style: italic; }
    .badge { background: linear-gradient(180deg,#111827,#0b1220); }
    /* scrolling smoothing */
    .scroll-smooth { scroll-behavior: smooth; }
  </style>
</head>
<body class="min-h-screen bg-gray-900 text-gray-100 mircss">
  <div class="max-w-6xl mx-auto p-3">
    <header class="flex items-center justify-between mb-3">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 bg-indigo-600 rounded flex items-center justify-center text-white font-bold">pIRC</div>
        <div>
          <h1 class="text-xl font-semibold">pIRC <span class="text-sm text-gray-400">mIRC-style web chat</span></h1>
          <p class="text-xs text-gray-400">Standalone HTML+JS+Tailwind — mobile friendly</p>
        </div>
      </div>

      <div class="flex items-center gap-2">
        <button id="btn-theme" class="px-3 py-1 rounded border border-gray-700 text-sm">Toggle Theme</button>
        <button id="btn-help" class="px-3 py-1 rounded bg-indigo-600 text-sm">Help / Commands</button>
      </div>
    </header>

    <main class="grid grid-cols-1 md:grid-cols-4 gap-3">
      <!-- Left: Connection + channels -->
      <aside class="md:col-span-1 bg-gray-800 rounded p-3 space-y-3">
        <form id="connect-form" class="space-y-2">
          <div class="flex gap-2">
            <input id="server" class="flex-1 bg-transparent border border-gray-700 rounded px-2 py-1 text-sm" placeholder="WebSocket URL (wss://)" value="wss://example-irc-ws.example/ws" />
          </div>
          <div class="grid grid-cols-2 gap-2">
            <input id="nick" class="bg-transparent border border-gray-700 rounded px-2 py-1 text-sm" placeholder="Nick" value="pircUser" />
            <input id="realname" class="bg-transparent border border-gray-700 rounded px-2 py-1 text-sm" placeholder="Real name" value="pIRC web client" />
          </div>
          <div class="flex gap-2">
            <button id="btn-connect" class="flex-1 px-2 py-1 rounded bg-green-600 text-sm">Connect</button>
            <button id="btn-disconnect" type="button" class="flex-1 px-2 py-1 rounded bg-red-600 text-sm" disabled>Disconnect</button>
          </div>
        </form>

        <section>
          <h2 class="text-xs text-gray-400 uppercase mb-2">Channels</h2>
          <ul id="channels-list" class="space-y-1 max-h-48 overflow-auto">
            <!-- channels added dynamically -->
          </ul>
        </section>

        <section>
          <h2 class="text-xs text-gray-400 uppercase mt-3 mb-2">Quick</h2>
          <div class="flex gap-2">
            <button id="btn-join-#general" class="px-2 py-1 rounded border border-gray-700 text-sm">#general</button>
            <button id="btn-join-#help" class="px-2 py-1 rounded border border-gray-700 text-sm">#help</button>
          </div>
        </section>
      </aside>

      <!-- Main chat area -->
      <section class="md:col-span-2 bg-gray-800 rounded p-2 flex flex-col" id="chat-area">
        <div class="flex items-center justify-between px-2 mb-2">
          <div>
            <strong id="current-channel">Not connected</strong>
            <div id="status" class="text-xs text-gray-400">Disconnected</div>
          </div>
          <div class="text-xs text-gray-400">
            <span id="conn-info"></span>
          </div>
        </div>

        <div id="messages" class="flex-1 overflow-auto rounded bg-gray-900 p-2 space-y-2 scroll-smooth" style="min-height:280px;"> 
          <!-- messages -->
        </div>

        <div class="mt-2">
          <div class="flex gap-2">
            <input id="input" class="flex-1 bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm" placeholder="Type a message or /command. e.g. /join #channel" autocomplete="off" />
            <button id="send" class="px-3 py-2 rounded bg-indigo-600">Send</button>
          </div>
          <div class="text-xs text-gray-500 mt-1">Swipe up to see older messages. Commands: /join, /part, /nick, /msg, /me, /raw</div>
        </div>
      </section>

      <!-- Right: nick list / settings -->
      <aside class="md:col-span-1 bg-gray-800 rounded p-3 flex flex-col">
        <div class="mb-3">
          <h3 class="text-sm font-semibold">Nicklist</h3>
          <div id="nicklist" class="mt-2 text-sm text-gray-300 max-h-64 overflow-auto"></div>
        </div>

        <div class="mt-auto">
          <h3 class="text-sm font-semibold">Settings</h3>
          <label class="flex items-center gap-2 mt-2 text-sm text-gray-300"><input id="autoscroll" type="checkbox" checked /> Auto-scroll</label>
          <label class="flex items-center gap-2 mt-2 text-sm text-gray-300"><input id="timestamps" type="checkbox" checked /> Show timestamps</label>
        </div>
      </aside>
    </main>

    <footer class="mt-3 text-xs text-gray-500">Built with HTML + JavaScript + Tailwind — pIRC</footer>
  </div>

  <!-- Help modal -->
  <div id="help-modal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-60 p-4">
    <div class="max-w-xl w-full bg-gray-800 rounded p-4">
      <h2 class="text-lg font-semibold">pIRC — Commands & help</h2>
      <ul class="list-disc pl-5 mt-3 text-sm text-gray-300 space-y-1">
        <li><strong>/join &lt;#channel&gt;</strong> - join a channel</li>
        <li><strong>/part &lt;#channel&gt;</strong> - leave channel</li>
        <li><strong>/nick &lt;newnick&gt;</strong> - change nick</li>
        <li><strong>/me &lt;action&gt;</strong> - action message</li>
        <li><strong>/msg &lt;nick&gt; &lt;message&gt;</strong> - private message</li>
        <li><strong>/raw &lt;raw-line&gt;</strong> - send raw IRC line to server</li>
        <li><strong>/clear</strong> - clear chat window</li>
      </ul>
      <div class="mt-4 flex justify-end">
        <button id="help-close" class="px-3 py-1 rounded bg-indigo-600">Close</button>
      </div>
    </div>
  </div>

<script>
/* pIRC — simple mIRC-style web client (frontend only)
   Notes:
   - This client speaks plain IRC over WebSocket. You need an IRC-to-WebSocket gateway that exposes IRC via websockets.
   - Example gateway: some IRC servers provide a websocket endpoint (wss://). For testing you can run a small websocket proxy that translates to IRC.
   - This is a frontend-only single file. No backend bundled.
*/

(() => {
  const $ = id => document.getElementById(id);
  const messages = $('messages');
  const channelsList = $('channels-list');
  const nicklistEl = $('nicklist');
  const currentChannelEl = $('current-channel');
  const statusEl = $('status');
  const connInfoEl = $('conn-info');

  let ws = null;
  let nick = $('nick').value || 'pircUser';
  let connected = false;
  let activeChannel = null;
  let autoscroll = true;
  let timestamps = true;

  function makeTimestamp() {
    if (!timestamps) return '';
    const d = new Date();
    const hh = d.getHours().toString().padStart(2,'0');
    const mm = d.getMinutes().toString().padStart(2,'0');
    return '['+hh+':'+mm+'] ';
  }

  function pushSystem(msg) {
    const el = document.createElement('div');
    el.className = 'msg-system text-sm';
    el.textContent = makeTimestamp() + msg;
    messages.appendChild(el);
    if (autoscroll) messages.scrollTop = messages.scrollHeight;
  }

  function pushMessage(from, text, isAction=false) {
    const wrap = document.createElement('div');
    wrap.className = 'p-1 rounded';
    const time = makeTimestamp();
    const nameEl = document.createElement('span');
    nameEl.className = 'msg-user text-indigo-300';
    nameEl.textContent = from;
    const sep = document.createElement('span');
    sep.className = 'text-gray-400 px-2';
    sep.textContent = ':';
    const textEl = document.createElement('span');
    textEl.className = 'text-sm';
    textEl.textContent = (isAction ? '\u0001ACTION ' : '') + text;

    if (isAction) {
      wrap.innerHTML = `<span class='text-gray-400'>${time}</span> <em>* ${from} ${text}</em>`;
    } else {
      wrap.innerHTML = `<span class='text-gray-400'>${time}</span> <span class='text-indigo-300 font-semibold'>${escapeHtml(from)}</span><span class='text-gray-400 px-2'>:</span> <span class='text-sm'>${escapeHtml(text)}</span>`;
    }
    messages.appendChild(wrap);
    if (autoscroll) messages.scrollTop = messages.scrollHeight;
  }

  function escapeHtml(s) {
    return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function updateChannelsUI() {
    channelsList.innerHTML = '';
    const chans = Object.keys(state.channels || {});
    if (chans.length === 0) {
      channelsList.innerHTML = '<li class="text-xs text-gray-500">No channels</li>';
      return;
    }
    chans.forEach(c => {
      const li = document.createElement('li');
      li.className = 'flex items-center justify-between p-1 rounded hover:bg-gray-700';
      li.innerHTML = `<div class='text-sm'>${escapeHtml(c)}</div><div class='text-xs text-gray-400'>${state.channels[c].users.length}</div>`;
      li.addEventListener('click', () => switchChannel(c));
      channelsList.appendChild(li);
    });
  }

  function updateNicklistUI(channel) {
    nicklistEl.innerHTML = '';
    const users = (state.channels[channel] && state.channels[channel].users) || [];
    users.forEach(u => {
      const el = document.createElement('div');
      el.className = 'py-0.5 text-sm border-b border-gray-800';
      el.textContent = u;
      nicklistEl.appendChild(el);
    });
  }

  function switchChannel(c) {
    activeChannel = c;
    currentChannelEl.textContent = c;
    updateNicklistUI(c);
    pushSystem('Switched to ' + c);
  }

  // Minimal state tracking for channels and nicks
  const state = { channels: {} };

  function ensureChannel(c) {
    if (!state.channels[c]) state.channels[c] = { users: [] };
  }

  function addUserToChannel(c, u) {
    ensureChannel(c);
    if (!state.channels[c].users.includes(u)) state.channels[c].users.push(u);
  }

  function removeUserFromChannel(c, u) {
    ensureChannel(c);
    state.channels[c].users = state.channels[c].users.filter(x => x !== u);
  }

  // -- IRC message parsing (very simple) --
  function parseIrcLine(line) {
    // line examples: ":nick!user@host PRIVMSG #chan :hello world"
    const original = line;
    let prefix = null;
    if (line.startsWith(':')) {
      const idx = line.indexOf(' ');
      prefix = line.slice(1, idx);
      line = line.slice(idx+1);
    }
    const spaceIdx = line.indexOf(' ');
    if (spaceIdx === -1) return;
    const command = line.slice(0, spaceIdx).toUpperCase();
    let rest = line.slice(spaceIdx+1).trim();

    if (command === 'PING') {
      sendRaw('PONG ' + rest);
      pushSystem('PING received -> auto PONG');
      return;
    }

    if (command === 'PRIVMSG') {
      // target and message
      const tgtEnd = rest.indexOf(' ');
      const target = rest.slice(0, tgtEnd);
      let msg = rest.slice(tgtEnd+2); // remove leading :
      const fromNick = prefix ? prefix.split('!')[0] : 'server';
      // action?
      if (msg.startsWith('\u0001ACTION')) {
        const actionText = msg.replace(/^\u0001ACTION\s*/,'').replace(/\u0001$/,'');
        pushMessage(fromNick, actionText, true);
      } else {
        pushMessage(fromNick, msg);
      }
      return;
    }

    if (command === 'JOIN') {
      const chan = rest.replace(/^:/,'');
      const who = prefix ? prefix.split('!')[0] : 'unknown';
      ensureChannel(chan);
      addUserToChannel(chan, who);
      pushSystem(`${who} joined ${chan}`);
      updateChannelsUI();
      if (!activeChannel) switchChannel(chan);
      return;
    }

    if (command === 'PART') {
      const [chan, ...restParts] = rest.split(' ');
      const who = prefix ? prefix.split('!')[0] : 'unknown';
      removeUserFromChannel(chan, who);
      pushSystem(`${who} left ${chan}`);
      updateChannelsUI();
      if (activeChannel === chan) updateNicklistUI(chan);
      return;
    }

    // Numeric replies and other server messages
    pushSystem(original);
  }

  function sendRaw(line) {
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      pushSystem('[local] Not connected');
      return;
    }
    ws.send(line + '\r\n');
    console.log('>>', line);
  }

  // UI events
  $('btn-help').addEventListener('click', () => $('help-modal').style.display = 'flex');
  $('help-close').addEventListener('click', () => $('help-modal').style.display = 'none');

  $('btn-theme').addEventListener('click', () => {
    document.documentElement.classList.toggle('dark');
    document.body.classList.toggle('bg-white');
  });

  $('btn-join-#general').addEventListener('click', () => { $('input').value = '/join #general'; $('input').focus(); });
  $('btn-join-#help').addEventListener('click', () => { $('input').value = '/join #help'; $('input').focus(); });

  $('autoscroll').addEventListener('change', (e) => autoscroll = e.target.checked);
  $('timestamps').addEventListener('change', (e) => timestamps = e.target.checked);

  $('btn-connect').addEventListener('click', (ev) => {
    ev.preventDefault();
    const url = $('server').value.trim();
    nick = $('nick').value.trim() || nick;
    if (!url) { pushSystem('Please enter a websocket URL'); return; }
    connect(url);
  });

  $('btn-disconnect').addEventListener('click', () => {
    if (ws) ws.close();
  });

  $('send').addEventListener('click', () => handleInput());
  $('input').addEventListener('keydown', (e) => { if (e.key === 'Enter') handleInput(); });

  function handleInput() {
    const v = $('input').value.trim();
    if (!v) return;
    if (v.startsWith('/')) {
      handleCommand(v);
    } else {
      // send to active channel or show error
      if (!activeChannel) { pushSystem('No active channel. Use /join <#channel> or specify /msg'); $('input').value = ''; return; }
      sendRaw(`PRIVMSG ${activeChannel} :${v}`);
      pushMessage(nick, v); // optimistic
    }
    $('input').value = '';
  }

  function handleCommand(line) {
    const parts = line.slice(1).split(' ');
    const cmd = parts.shift().toLowerCase();
    if (cmd === 'join') {
      const chan = parts[0];
      if (!chan) { pushSystem('Usage: /join #channel'); return; }
      sendRaw('JOIN ' + chan);
      ensureChannel(chan);
      if (!activeChannel) switchChannel(chan);
      updateChannelsUI();
    } else if (cmd === 'part') {
      const chan = parts[0] || activeChannel;
      if (!chan) { pushSystem('Usage: /part #channel'); return; }
      sendRaw('PART ' + chan);
      delete state.channels[chan];
      updateChannelsUI();
      if (activeChannel === chan) { activeChannel = null; currentChannelEl.textContent = '—'; }
    } else if (cmd === 'nick') {
      const newNick = parts[0];
      if (!newNick) { pushSystem('Usage: /nick newnick'); return; }
      sendRaw('NICK ' + newNick);
      nick = newNick;
      $('nick').value = newNick;
    } else if (cmd === 'me') {
      const text = parts.join(' ');
      if (!text) return;
      sendRaw(`PRIVMSG ${activeChannel} :\u0001ACTION ${text}\u0001`);
      pushMessage(nick, text, true);
    } else if (cmd === 'msg') {
      const target = parts.shift();
      const text = parts.join(' ');
      if (!target || !text) { pushSystem('Usage: /msg nick message'); return; }
      sendRaw(`PRIVMSG ${target} :${text}`);
      pushMessage(`-> ${target}`, text);
    } else if (cmd === 'raw') {
      const raw = parts.join(' ');
      sendRaw(raw);
    } else if (cmd === 'clear') {
      messages.innerHTML = '';
    } else {
      pushSystem('Unknown command: ' + cmd);
    }
  }

  // Connect function
  function connect(url) {
    try {
      ws = new WebSocket(url);
    } catch (e) {
      pushSystem('Invalid WebSocket URL');
      return;
    }
    statusEl.textContent = 'Connecting...';
    $('btn-connect').disabled = true;

    ws.addEventListener('open', () => {
      connected = true;
      statusEl.textContent = 'Connected';
      $('btn-disconnect').disabled = false;
      connInfoEl.textContent = url;
      // send initial registration lines — some gateways accept NICK/USER
      sendRaw('NICK ' + nick);
      sendRaw('USER ' + (document.getElementById('realname').value || 'pIRC') + ' 0 * :pIRC web client');
      pushSystem('Connected to ' + url);
    });

    ws.addEventListener('message', ev => {
      const data = ev.data + '';
      // Some gateways send multiple lines joined
      const lines = data.split(/\r?\n/).filter(Boolean);
      lines.forEach(l => parseIrcLine(l));
    });

    ws.addEventListener('close', (ev) => {
      connected = false;
      statusEl.textContent = 'Disconnected';
      $('btn-connect').disabled = false;
      $('btn-disconnect').disabled = true;
      pushSystem('Disconnected');
    });

    ws.addEventListener('error', (ev) => {
      pushSystem('WebSocket error');
      console.error(ev);
    });
  }

  // small utility: allow tapping nick names to /msg
  nicklistEl.addEventListener('click', (ev) => {
    const t = ev.target.closest('div');
    if (!t) return;
    const name = t.textContent.trim();
    $('input').value = `/msg ${name} `;
    $('input').focus();
  });

  // initial demo tips
  pushSystem('Welcome to pIRC — enter a WebSocket IRC gateway URL and connect.');
  pushSystem('Example: wss://irc-ws.example/ws (you need an IRC websocket gateway)');

})();
</script>
</body>
</html>
